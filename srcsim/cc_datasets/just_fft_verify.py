import numpy as np
from matplotlib import pyplot as plt
from scipy.fft import fft, fftfreq

fft_input_file = 'trigger.data' # data that was fed into the FFT IP core
fft_output_file = 'just_fft_tb_out.txt' # output generated by the FFT IP core


def bit_reverse(k):
    x = bin(k)
    x = x[2:len(x)]
    x = x[::-1]
    x = int(x, 2)
    return x

N = 256 # 256 point FFT
Fs = 446000

t_step = (1/Fs)
freq = 30000
t = np.arange(N)

# do a SciPy FFT on the input dataset and plot it
input_data = np.loadtxt(fft_input_file, dtype='int32', converters={_:lambda s: int(s, 16) for _ in range(1)})
scipy_fft = fft(input_data) ** 2
scipy_fft_freq = fftfreq(N, t_step)
plt.subplot(311)
plt.stem(scipy_fft_freq, scipy_fft)
plt.title('SciPy FFT')
plt.xlabel('f, Hz')


# load in the data
sfft    = np.loadtxt(fft_output_file)
#ufft    = sfft[0::2]**2 + sfft[1::2]**2     # real magnitude^2 + imaginary magnitude^2
                                            # real #s are in even indices, imaginary in odd
ufft = sfft[0::2]**2


real_order = np.zeros(N)
for i in range(0, N) :
    real_order[bit_reverse(i)] = ufft[i] 

rtl_freq_axis = np.arange(0, Fs, Fs/N)

plt.subplot(312)
plt.stem(rtl_freq_axis[1:], real_order[1:])
#plt.plot(f_axis/1e6,10*np.log10(ufft/np.max(ufft)),'.-b')
#plt.plot(f_axis/1e6, SNR_signal, '.-r', label="Input SNR is {} dB".format(snr))
#plt.plot(f_axis/1e6, SNR_FFT, '.-k', label="FFT SNR is 10*log10({}) = {} dB".format(N, np.round(10*np.log10(N))))
#plt.legend(loc="upper right")
plt.title('FPGA FFT RTL Simulation')
plt.xlabel('f, Hz')
plt.grid()
plt.show()